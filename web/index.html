<!DOCTYPE html>
<html>
<head>
    <title>S3-to-WebDAV Bridge</title>
    <meta charset="utf-8">
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
            margin: 0;
            background: #f6f6f9;
            color: #242438;
        }
        .header {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 24px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0;
            font-weight: 600;
            font-size: 28px;
            letter-spacing: -0.5px;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }

        .credentials-bar {
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.04);
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            border: 1px solid #e5e7eb;
        }
        .credentials-bar input {
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 14px;
            flex: 1;
            min-width: 200px;
            transition: all 0.2s ease;
        }
        .credentials-bar input:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .main-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.04);
            padding: 24px;
            min-width: 300px;
            max-width: 350px;
            border: 1px solid #e5e7eb;
        }
        .sidebar h3 {
            margin: 0 0 20px 0;
            color: #8b5cf6;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: 600;
        }

        .content-area {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.04);
            padding: 24px;
            min-height: 500px;
            border: 1px solid #e5e7eb;
        }

        .btn {
            background: #8b5cf6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover {
            background: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }
        .btn-sm { padding: 6px 12px; font-size: 13px; }
        .btn-danger { background: #ef4444; }
        .btn-danger:hover {
            background: #dc2626;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .bucket-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin: 4px -16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .bucket-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
        }
        .bucket-item.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
        }
        .bucket-icon { margin-right: 12px; font-size: 18px; }

        .breadcrumb {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
        }

        .breadcrumb-path {
            display: flex;
            align-items: center;
        }
        .breadcrumb a {
            color: #8b5cf6;
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        .breadcrumb a:hover {
            background: #f3f4f6;
            color: #7c3aed;
        }
        .breadcrumb span { margin: 0 8px; color: #d1d5db; }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            margin: 15% auto;
            padding: 24px;
            border-radius: 12px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
        }

        .modal h3 {
            margin: 0 0 20px 0;
            color: #242438;
            font-size: 20px;
            font-weight: 600;
        }

        .modal input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .modal input:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #6b7280;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
            color: #374151;
            transform: none;
            box-shadow: none;
        }

        .file-list {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
        }
        .file-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.2s ease;
        }
        .file-item:hover {
            background: #f9fafb;
            transform: translateX(2px);
        }
        .file-item:last-child { border-bottom: none; }
        .file-item.folder { cursor: pointer !important; }
        .file-item.folder:hover {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-left: 3px solid #8b5cf6;
        }

        .file-icon {
            width: 24px;
            margin-right: 16px;
            text-align: center;
            font-size: 20px;
            opacity: 0.8;
        }
        .file-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .file-name {
            font-weight: 600;
            margin-bottom: 4px;
            color: #242438;
            font-size: 15px;
        }
        .file-meta {
            font-size: 13px;
            color: #6b7280;
            font-weight: 400;
        }
        .file-actions {
            display: flex;
            gap: 8px;
        }

        .upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 48px 24px;
            text-align: center;
            margin: 24px 0;
            transition: all 0.2s ease;
            cursor: pointer;
            background: #fafbfc;
        }
        .upload-zone:hover, .upload-zone.dragover {
            border-color: #8b5cf6;
            background: linear-gradient(135deg, #faf5ff 0%, #f3f4f6 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.15);
        }
        .upload-zone input[type="file"] { display: none; }

        .empty-state {
            text-align: center;
            padding: 60px 24px;
            color: #6b7280;
        }
        .empty-state .icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.4;
            filter: grayscale(0.3);
        }
        .empty-state p {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }

        .message {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 20px;
            border-radius: 12px;
            color: white;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            font-weight: 500;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
        }
        .message.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        .message.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        .message.info {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content { flex-direction: column; }
            .sidebar { max-width: none; }
            .credentials-bar { flex-direction: column; align-items: stretch; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üóÇÔ∏è S3-to-WebDAV Bridge</h1>
    </div>

    <div class="container">
        <div class="credentials-bar">
            <input type="text" id="accessKey" placeholder="Access Key (optional for insecure mode)" disabled />
            <input type="password" id="secretKey" placeholder="Secret Key (optional for insecure mode)" />
            <div id="readOnlyBanner" style="display: none; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.1); white-space: nowrap;">
                üîí Read-Only
            </div>
            <small style="color: #666; flex-basis: 100%;">Leave empty if server allows insecure access</small>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>
                    üìÅ Buckets
                    <button class="btn btn-sm" onclick="refreshBuckets()">üîÑ</button>
                </h3>
                <div id="bucketList"></div>
            </div>

            <div class="content-area">
                <div class="breadcrumb" id="breadcrumb">
                    <div class="breadcrumb-path">
                        <span>Select a bucket to view contents</span>
                    </div>
                    <button class="btn btn-sm" id="goToPathBtn" onclick="showGoToPathModal()" style="display: none;">üöÄ Go to Path</button>
                </div>

                <div id="contentArea">
                    <div class="empty-state">
                        <div class="icon">üìÇ</div>
                        <p>Choose a bucket from the sidebar to get started</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Go to Path Modal -->
    <div id="goToPathModal" class="modal">
        <div class="modal-content">
            <h3>Navigate to Path</h3>
            <p style="color: #6b7280; font-size: 14px; margin-bottom: 16px;">
                Enter a path to navigate to. Folders will be created automatically when you upload files.
            </p>
            <input type="text" id="pathInput" placeholder="e.g., documents/projects/2024/" />
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="hideGoToPathModal()">Cancel</button>
                <button class="btn" onclick="goToPath()">Go to Path</button>
            </div>
        </div>
    </div>

    <script>
        let config = {};
        let credentials = { endpoint: `${window.location.protocol}//${window.location.host}` };
        let selectedBucket = '';
        let currentPath = '';
        let currentObjects = [];
        let nextMarker = '';
        let isTruncated = false;
        let isReadOnly = false;

        function initConfig() {
            loadCredentials();
            saveCredentials();
            parseUrlAndNavigate();
            refreshBuckets();
        }

        function loadCredentials() {
            const accessKey = sessionStorage.getItem('s3_access_key');
            const secretKey = sessionStorage.getItem('s3_secret_key');

            const urlParams = new URLSearchParams(window.location.search);
            const urlAccessKey = urlParams.get('access_key');
            const urlReadOnly = urlParams.get('read_only');

            if (accessKey) {
                document.getElementById('accessKey').value = accessKey;
            }
            if (urlAccessKey) {
                document.getElementById('accessKey').value = urlAccessKey;
                sessionStorage.setItem('s3_access_key', urlAccessKey);
            }
            if (secretKey) {
                document.getElementById('secretKey').value = secretKey;
            }

            isReadOnly = urlReadOnly === 'true';

            if (isReadOnly) {
                document.getElementById('readOnlyBanner').style.display = 'inline-block';
            }
        }

        function parseUrlAndNavigate() {
            const path = window.location.pathname;
            const match = path.match(/^\/-\/browser(?:\/([^\/]+)(?:\/(.*))?)?$/);

            if (match) {
                const bucket = match[1];
                const objectPath = match[2] || '';

                if (bucket) {
                    selectedBucket = bucket;
                    currentPath = objectPath;

                    setTimeout(() => {
                        const bucketItem = Array.from(document.querySelectorAll('.bucket-item'))
                            .find(item => item.textContent.trim() === selectedBucket);
                        if (bucketItem) {
                            bucketItem.classList.add('active');
                        }
                        loadBucketContents(currentPath);
                    }, 100);
                }
            }
        }

        function updateUrl(bucket, path = '') {
            const urlParams = new URLSearchParams(window.location.search);
            const newPath = `/-/browser/${bucket}${path ? '/' + path : ''}`;
            const queryString = urlParams.toString();
            const newUrl = newPath + (queryString ? '?' + queryString : '');
            window.history.pushState({bucket, path}, '', newUrl);
        }

        function saveCredentials() {
            credentials.accessKey = document.getElementById('accessKey').value;
            credentials.secretKey = document.getElementById('secretKey').value;

            if (credentials.accessKey) {
                sessionStorage.setItem('s3_access_key', credentials.accessKey);
            } else {
                sessionStorage.removeItem('s3_access_key');
            }

            if (credentials.secretKey) {
                sessionStorage.setItem('s3_secret_key', credentials.secretKey);
            } else {
                sessionStorage.removeItem('s3_secret_key');
            }
        }

        function showMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 4000);
        }

        async function sha256(message) {
            let msgBuffer;

            if (message instanceof File || message instanceof Blob) {
                // For File/Blob objects, use arrayBuffer()
                msgBuffer = await message.arrayBuffer();
            } else if (message instanceof ArrayBuffer) {
                msgBuffer = message;
            } else {
                // For strings, use TextEncoder
                msgBuffer = new TextEncoder().encode(message || '');
            }

            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function hmacSha256(key, message) {
            const keyBuffer = typeof key === 'string' ? new TextEncoder().encode(key) : key;
            const messageBuffer = new TextEncoder().encode(message);
            const cryptoKey = await crypto.subtle.importKey('raw', keyBuffer, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageBuffer);
            return new Uint8Array(signature);
        }

        async function getSignatureKey(key, dateStamp, regionName, serviceName) {
            const kDate = await hmacSha256('AWS4' + key, dateStamp);
            const kRegion = await hmacSha256(kDate, regionName);
            const kService = await hmacSha256(kRegion, serviceName);
            const kSigning = await hmacSha256(kService, 'aws4_request');
            return kSigning;
        }

        async function signRequest(method, url, headers, payloadHash256, credentials) {
            const now = new Date();
            const amzDate = now.toISOString().replace(/[:\-]|\.\d{3}/g, '');
            const dateStamp = amzDate.substr(0, 8);

            const region = 'us-east-1';
            const service = 's3';
            const algorithm = 'AWS4-HMAC-SHA256';
            const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;

            headers['X-Amz-Date'] = amzDate;

            const signedHeaders = Object.keys(headers).map(k => k.toLowerCase()).sort().join(';');
            const canonicalHeaders = Object.keys(headers)
                .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
                .map(k => `${k.toLowerCase()}:${headers[k].toString().trim()}\n`)
                .join('');

            const urlObj = new URL(url);
            const canonicalPath = urlObj.pathname;

            const queryParams = [];
            for (const [key, value] of urlObj.searchParams.entries()) {
                queryParams.push([encodeURIComponent(key), encodeURIComponent(value)]);
            }
            queryParams.sort((a, b) => a[0].localeCompare(b[0]));
            const canonicalQueryString = queryParams.map(([key, value]) => `${key}=${value}`).join('&');

            const canonicalRequest = [
                method,
                canonicalPath,
                canonicalQueryString,
                canonicalHeaders,
                signedHeaders,
                payloadHash256 || 'UNSIGNED-PAYLOAD'
            ].join('\n');

            const stringToSign = [
                algorithm,
                amzDate,
                credentialScope,
                await sha256(canonicalRequest)
            ].join('\n');

            const signingKey = await getSignatureKey(credentials.secretKey, dateStamp, region, service);
            const signature = await hmacSha256(signingKey, stringToSign);
            const signatureHex = Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join('');

            const authorizationHeader = `${algorithm} Credential=${credentials.accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signatureHex}`;

            return authorizationHeader;
        }

        async function makeS3Request(path, method = 'GET', body = null, headers = {}, options = {}) {
            saveCredentials();

            const url = credentials.endpoint + path;

            const defaultHeaders = {
                'Host': new URL(url).host,
                ...headers
            };

            if (credentials.accessKey && credentials.secretKey) {
                try {
                    const payloadHash256 = options.skipHash ? 'UNSIGNED-PAYLOAD' : await sha256(body || '');
                    const authHeader = await signRequest(method, url, defaultHeaders, payloadHash256, credentials);
                    defaultHeaders['Authorization'] = authHeader;
                    defaultHeaders['X-Amz-Content-Sha256'] = payloadHash256;
                } catch (error) {
                    console.error('Failed to sign request:', error);
                    showMessage('Failed to sign request', 'error');
                    return null;
                }
            }

            try {
                const response = await fetch(url, {
                    method,
                    headers: defaultHeaders,
                    body
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return response;
            } catch (error) {
                showMessage(`Request failed: ${error.message}`, 'error');
                return null;
            }
        }

        async function refreshBuckets() {
            const bucketListDiv = document.getElementById('bucketList');
            bucketListDiv.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="loading"></div></div>';

            const response = await makeS3Request('/');
            if (!response) {
                bucketListDiv.innerHTML = '<div class="empty-state"><p>Failed to load buckets</p></div>';
                return;
            }

            const text = await response.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, 'text/xml');

            const buckets = Array.from(xmlDoc.querySelectorAll('Bucket Name')).map(node => node.textContent);

            if (buckets.length === 0) {
                bucketListDiv.innerHTML = '<div class="empty-state"><p>No buckets found</p></div>';
                return;
            }

            bucketListDiv.innerHTML = '';
            buckets.forEach(bucket => {
                const bucketDiv = document.createElement('div');
                bucketDiv.className = `bucket-item ${selectedBucket === bucket ? 'active' : ''}`;
                bucketDiv.onclick = () => selectBucket(bucket);
                bucketDiv.innerHTML = `
                    <span class="bucket-icon">üóÇÔ∏è</span>
                    <span>${bucket}</span>
                `;
                bucketListDiv.appendChild(bucketDiv);
            });
        }

        function selectBucket(bucket) {
            selectedBucket = bucket;
            currentPath = '';

            document.querySelectorAll('.bucket-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.bucket-item').classList.add('active');

            updateUrl(bucket);
            loadBucketContents();
        }

        async function loadBucketContents(path = '', loadMore = false) {
            if (!selectedBucket) return;

            if (!loadMore) {
                currentPath = path;
                currentObjects = [];
                nextMarker = '';
                isTruncated = false;
                updateBreadcrumb(path);
                updateUrl(selectedBucket, path);
            }

            // Show Go to Path button when bucket is selected
            document.getElementById('goToPathBtn').style.display = 'block';

            const contentArea = document.getElementById('contentArea');
            if (!loadMore) {
                contentArea.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="loading"></div></div>';
            }

            // Use prefix parameter and delimiter for proper folder navigation
            const prefix = path || '';
            let queryParams = `prefix=${prefix}&delimiter=/&max-keys=100`;

            if (loadMore && nextMarker) {
                queryParams += `&marker=${encodeURIComponent(nextMarker)}`;
            }

            const response = await makeS3Request(`/${selectedBucket}?${queryParams}`);
            if (!response) {
                contentArea.innerHTML = '<div class="empty-state"><div class="icon">‚ùå</div><p>Failed to load contents</p></div>';
                return;
            }

            const text = await response.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, 'text/xml');

            // Check if results are truncated
            const truncatedElement = xmlDoc.querySelector('IsTruncated');
            isTruncated = truncatedElement ? truncatedElement.textContent.toLowerCase() === 'true' : false;

            // Get folders from CommonPrefixes
            const folders = Array.from(xmlDoc.querySelectorAll('CommonPrefixes Prefix')).map(prefix => ({
                key: prefix.textContent,
                isFolder: true,
                size: 0,
                lastModified: new Date().toISOString(),
                displayName: prefix.textContent.split('/').filter(p => p).pop()
            }));

            // Get files from Contents
            const files = Array.from(xmlDoc.querySelectorAll('Contents')).map(content => ({
                key: content.querySelector('Key').textContent,
                size: parseInt(content.querySelector('Size').textContent),
                lastModified: content.querySelector('LastModified').textContent,
                isFolder: false,
                displayName: content.querySelector('Key').textContent.split('/').pop()
            }));

            // Set next marker for pagination
            const nextMarkerElement = xmlDoc.querySelector('NextMarker');
            if (nextMarkerElement && nextMarkerElement.textContent) {
                nextMarker = nextMarkerElement.textContent;
            } else if (isTruncated) {
                // If no explicit NextMarker, find the last key from the original S3 response
                // We need to use the last item from the combined results before sorting
                const allResponseItems = [...folders, ...files];
                if (allResponseItems.length > 0) {
                    // Find the lexicographically last key
                    const sortedByKey = allResponseItems.sort((a, b) => a.key.localeCompare(b.key));
                    nextMarker = sortedByKey[sortedByKey.length - 1].key;
                }
            } else {
                nextMarker = '';
            }

            // Combine and sort items for display (folders first, then files)
            const newItems = [...folders, ...files].sort((a, b) => {
                if (a.isFolder && !b.isFolder) return -1;
                if (!a.isFolder && b.isFolder) return 1;
                return a.displayName.localeCompare(b.displayName);
            });

            if (loadMore) {
                currentObjects = [...currentObjects, ...newItems];
            } else {
                currentObjects = newItems;
            }

            renderFileList(currentObjects, loadMore);
        }


        function renderFileList(objects, isLoadMore = false) {
            const contentArea = document.getElementById('contentArea');

            if (objects.length === 0 && !isLoadMore) {
                const pathDisplay = currentPath ? `"${currentPath}"` : 'root';
                contentArea.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üìÇ</div>
                        <p>This path is empty: ${pathDisplay}</p>
                    </div>
                    ${getUploadZone()}
                `;
                return;
            }

            let fileListDiv;
            if (isLoadMore) {
                // Find existing file list and remove load more button if present
                fileListDiv = contentArea.querySelector('.file-list');
                const loadMoreBtn = contentArea.querySelector('.load-more-btn');
                if (loadMoreBtn) {
                    loadMoreBtn.remove();
                }
            } else {
                // Create new file list
                fileListDiv = document.createElement('div');
                fileListDiv.className = 'file-list';
                contentArea.innerHTML = '';
                contentArea.appendChild(fileListDiv);
            }

            // Add new items to the file list
            const startIndex = isLoadMore ? fileListDiv.children.length : 0;
            const newItems = isLoadMore ? objects.slice(startIndex) : objects;

            newItems.forEach(obj => {
                const fileItem = document.createElement('div');
                fileItem.className = obj.isFolder ? 'file-item folder' : 'file-item';

                const icon = getFileIcon(obj.key, obj.isFolder);
                const fileName = obj.displayName || (obj.isFolder ?
                    (obj.key.endsWith('/') ? obj.key.slice(0, -1) : obj.key).split('/').pop() :
                    obj.key.split('/').pop());

                fileItem.innerHTML = `
                    <div class="file-icon">${icon}</div>
                    <div class="file-info">
                        <div class="file-name">${fileName}</div>
                        <div class="file-meta">
                            ${obj.isFolder ? 'Folder' : formatBytes(obj.size) + ' ‚Ä¢ ' + new Date(obj.lastModified).toLocaleDateString()}
                        </div>
                    </div>
                    <div class="file-actions">
                        ${obj.isFolder ? `` : `
                            <button class="btn btn-sm" onclick="downloadObject('${obj.key}')">üì•</button>
                            ${isReadOnly ? '' : `<button class="btn btn-sm btn-danger" onclick="deleteObject('${obj.key}')">üóëÔ∏è</button>`}
                        `}
                    </div>
                `;

                if (obj.isFolder) {
                    fileItem.setAttribute("onclick", `navigateToFolder('${obj.key}')`);
                }

                fileListDiv.appendChild(fileItem);
            });

            // Add Load More button if results are truncated
            if (isTruncated) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.style.cssText = 'text-align: center; padding: 20px; border-top: 1px solid #e5e7eb;';
                loadMoreBtn.innerHTML = `
                    <button class="btn" onclick="loadMoreObjects()" id="loadMoreButton">
                        üìÑ Load More (showing ${objects.length} items)
                    </button>
                `;
                contentArea.appendChild(loadMoreBtn);
            }

            // Add upload zone if not loading more
            if (!isLoadMore) {
                contentArea.innerHTML += getUploadZone();
            } else {
                // Make sure upload zone is at the end
                const uploadZone = contentArea.querySelector('.upload-zone');
                if (uploadZone) {
                    contentArea.appendChild(uploadZone);
                } else {
                    contentArea.innerHTML += getUploadZone();
                }
            }
        }

        function getUploadZone() {
            if (isReadOnly) {
                return '';
            }
            const pathDisplay = currentPath ? `${currentPath}` : 'root';
            return `
                <div class="upload-zone" onclick="document.getElementById('fileInput').click()" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <input type="file" id="fileInput" multiple onchange="handleFileSelect(event)" />
                    <p>üìÅ Drop files here or click to select</p>
                    <small style="color: #8b5cf6; margin-top: 8px; display: block;">
                        Files will be uploaded to: <strong>${pathDisplay}</strong>
                    </small>
                </div>
            `;
        }

        function updateBreadcrumb(path) {
            const breadcrumbPath = document.querySelector('.breadcrumb-path');
            const parts = path ? path.split('/').filter(p => p) : [];

            let breadcrumbHTML = `<a href="#" onclick="loadBucketContents('')">üè† ${selectedBucket}</a>`;

            let buildPath = '';
            parts.forEach((part, index) => {
                buildPath += part;
                if (index < parts.length - 1 || path.endsWith('/')) {
                    buildPath += '/';
                }

                breadcrumbHTML += ` <span>/</span> `;
                if (index === parts.length - 1 && !path.endsWith('/')) {
                    breadcrumbHTML += `<span>${part}</span>`;
                } else {
                    breadcrumbHTML += `<a href="#" onclick="loadBucketContents('${buildPath}')">${part}</a>`;
                }
            });

            breadcrumbPath.innerHTML = breadcrumbHTML;
        }

        function getFileIcon(key, isFolder) {
            if (isFolder) return 'üìÅ';

            const ext = key.split('.').pop().toLowerCase();
            const iconMap = {
                'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è', 'svg': 'üñºÔ∏è',
                'pdf': 'üìÑ', 'doc': 'üìÑ', 'docx': 'üìÑ', 'txt': 'üìÑ', 'md': 'üìÑ',
                'mp4': 'üé•', 'avi': 'üé•', 'mov': 'üé•', 'mkv': 'üé•',
                'mp3': 'üéµ', 'wav': 'üéµ', 'flac': 'üéµ',
                'zip': 'üì¶', 'rar': 'üì¶', 'tar': 'üì¶', 'gz': 'üì¶',
                'js': '‚ö°', 'html': 'üåê', 'css': 'üé®', 'json': 'üìã'
            };

            return iconMap[ext] || 'üìÑ';
        }

        async function downloadObject(key) {
            const response = await makeS3Request(`/${selectedBucket}/${key}`);
            if (!response) return;

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = key.split('/').pop();
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            showMessage(`Downloaded: ${key.split('/').pop()}`, 'success');
        }

        async function deleteObject(key) {
            if (isReadOnly) {
                showMessage('Delete operations are disabled in read-only mode', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to delete ${key.split('/').pop()}?`)) {
                return;
            }

            const response = await makeS3Request(`/${selectedBucket}/${key}`, 'DELETE');
            if (!response) return;

            showMessage(`Deleted: ${key.split('/').pop()}`, 'success');
            loadBucketContents(currentPath);
        }

        async function uploadFile(file) {
            if (isReadOnly) {
                showMessage('Upload operations are disabled in read-only mode', 'error');
                return;
            }

            if (!selectedBucket) {
                showMessage('Please select a bucket first', 'error');
                return;
            }

            const objectKey = currentPath + file.name;
            showMessage(`Uploading: ${file.name}...`, 'info');

            // For files >= 10MB, skip SHA256 hash generation
            const skipHash = file.size >= 10 * 1024 * 1024;

            const response = await makeS3Request(`/${selectedBucket}/${objectKey}`, 'PUT', file, {
                'Content-Type': file.type || 'application/octet-stream',
                'Content-Length': file.size.toString()
            }, { skipHash });

            if (!response) return;

            showMessage(`Uploaded: ${file.name}`, 'success');
            loadBucketContents(currentPath);
        }

        function handleFileSelect(event) {
            Array.from(event.target.files).forEach(file => uploadFile(file));
            event.target.value = '';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            Array.from(event.dataTransfer.files).forEach(file => uploadFile(file));
        }

        function navigateToFolder(folderKey) {
            loadBucketContents(folderKey);
        }

        async function loadMoreObjects() {
            if (!isTruncated || !selectedBucket) return;

            const loadMoreButton = document.getElementById('loadMoreButton');
            if (loadMoreButton) {
                loadMoreButton.innerHTML = '<div class="loading"></div> Loading...';
                loadMoreButton.disabled = true;
            }

            await loadBucketContents(currentPath, true);

            if (loadMoreButton) {
                loadMoreButton.disabled = false;
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        // Auto-refresh credentials when typing
        document.getElementById('accessKey').addEventListener('input', saveCredentials);
        document.getElementById('secretKey').addEventListener('input', saveCredentials);

        // Handle browser navigation
        window.addEventListener('popstate', function(event) {
            if (event.state) {
                selectedBucket = event.state.bucket;
                currentPath = event.state.path || '';

                // Update UI to reflect the navigation
                document.querySelectorAll('.bucket-item').forEach(item => {
                    item.classList.toggle('active', item.textContent.trim() === selectedBucket);
                });

                loadBucketContents(currentPath);
            }
        });

        // Go to path functions
        function showGoToPathModal() {
            const modal = document.getElementById('goToPathModal');
            const input = document.getElementById('pathInput');

            // Pre-fill with current path
            input.value = currentPath;
            modal.style.display = 'block';
            input.focus();
            input.select();
        }

        function hideGoToPathModal() {
            document.getElementById('goToPathModal').style.display = 'none';
            document.getElementById('pathInput').value = '';
        }

        function goToPath() {
            let path = document.getElementById('pathInput').value.trim();

            if (!selectedBucket) {
                showMessage('Please select a bucket first', 'error');
                return;
            }

            // Normalize path - remove leading/trailing slashes, replace backslashes
            path = path.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');

            // If path is not empty, ensure it ends with /
            if (path && !path.endsWith('/')) {
                path += '/';
            }

            hideGoToPathModal();

            // Navigate to the path (even if it doesn't exist)
            loadBucketContents(path);
            showMessage(`Navigated to: ${path || 'root'}`, 'success');
        }

        // Close modal when clicking outside
        document.getElementById('goToPathModal').onclick = function(event) {
            if (event.target === this) {
                hideGoToPathModal();
            }
        }

        // Handle Enter key in path input
        document.getElementById('pathInput').onkeypress = function(event) {
            if (event.key === 'Enter') {
                goToPath();
            }
        }

        initConfig();
    </script>
</body>
</html>
